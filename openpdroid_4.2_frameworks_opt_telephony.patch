diff --git a/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
new file mode 100644
index 0000000..0c99dbb
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
@@ -0,0 +1,332 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMALTEPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMALTEPhone extends CDMALTEPhone{
+
+	private static final String P_TAG = "PrivacyCDMALTEPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context, cmdI, pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getMsisdn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMsisdn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMsisdn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+//	public IsimRecords getIsimRecords() {
+//		return null;
+//	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
new file mode 100644
index 0000000..77c7974
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
@@ -0,0 +1,312 @@
+/**
+* Copyright (C) 2012 Stefen Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMAPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMAPhone extends CDMAPhone{
+
+	private static final String P_TAG = "PrivacyCDMAPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMAPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyGSMPhone.java b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
new file mode 100644
index 0000000..5033815
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
@@ -0,0 +1,314 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.gsm.GSMPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyGSMPhone extends GSMPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyGSMPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
new file mode 100644
index 0000000..5da6d27
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
@@ -0,0 +1,644 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+import android.os.Process;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+
+import com.android.internal.telephony.PhoneConstants;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * @deprecated normally this class is not neeeded anymore, since we got privacy phones. The only method which is interesting is getPhoneSubInfo 
+ * {@hide}
+ */
+
+public class PrivacyPhoneProxy extends PhoneProxy{
+
+	private static final String P_TAG = "PrivacyPhoneProxy";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	private boolean context_available;
+	
+	/** This PackageManager is needed to get package name if context is not available*/
+	private IPackageManager mPm;
+	
+	public PrivacyPhoneProxy(PhoneBase mPhone, Context context) { //not sure if context is available, so test it!
+		super(mPhone);
+		if(context != null){
+			this.context = context;
+			context_available = true;
+		}
+		else{
+			context_available = false;
+		}
+		initiate(context_available);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	/**
+	 * Method for initalize variables depends on context is availabe or not
+	 * @param ctx_av pass true, if context is available and false if not
+	 * {@hide}
+	 */
+	private void initiate(boolean ctx_av){
+		if(ctx_av){
+			Log.i(P_TAG,"Context is available for package:" + context.getPackageName());
+		} else{
+			Log.e(P_TAG,"Context is not available for package: " + context.getPackageName());
+			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+		}
+	}
+	
+	
+	/**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(P_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    
+    @Override
+    public Connection dial(String dialNumber) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.dial(dialNumber); 
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], -1);
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber); 
+			}
+			else{
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+    
+    @Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.dial(dialNumber, uusInfo);
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], -1);
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo); 
+			}
+			else{
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+
+	@Override
+	public CellLocation getCellLocation() {
+		int phone_type = super.getPhoneType();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+		}
+		else{ //context is not available, go through uid!
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getCellLocation(); //we give cell location, because we can't get any package information in this process
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+		}
+	}
+	
+	@Override
+	public PhoneConstants.DataState getDataConnectionState() {
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING; //it's the best way to tell system that we are connecting
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDataConnectionState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING;
+			}
+		}
+	}
+	
+//	@Override
+//	public State getState() {
+//		State.
+//		return null;
+//	}
+	
+//	@Override
+//	public String getPhoneName() {
+//		return null;
+//	}
+	
+//	@Override
+//	public int getPhoneType() {
+//		return 0;
+//	}
+	
+	@Override
+	public SignalStrength getSignalStrength() {
+		SignalStrength output = new SignalStrength();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSignalStrength();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+		}
+	}
+	
+//	@Override
+//	public IccCard getIccCard() {
+//		return null;
+//	}
+
+	@Override
+	public String getLine1Number() {
+	   if(context_available){
+		   String packageName = context.getPackageName();
+	       int uid = Process.myUid();
+	       PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	       String output;
+	       if (pSet != null && pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+	           output = pSet.getLine1Number(); // can be empty, custom or random
+	           pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getLine1Number()");
+	       } else {
+	           output = super.getLine1Number();
+	           pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getLine1Number()");
+	       }
+	       return output;
+	   }
+	   else{
+		    String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getLine1Number();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getLine1Number()");
+				return output;
+			}
+			else{
+				output = settings.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getLine1Number()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the Line1Number.
+	 */
+	@Override
+	public String getLine1AlphaTag() {
+		return getLine1Number();
+	}
+	
+	/**
+	 * Will be handled like the Line1Number, since voice mailbox numbers often
+	 * are similar to the phone number of the subscriber.
+	 */
+	@Override
+	public String getVoiceMailNumber() {
+		return getLine1Number();
+	}
+	
+	//will look at this later!
+//	@Override
+//	public void getNeighboringCids(Message response) {
+//		
+//	}
+	
+	@Override
+	public String getDeviceId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getDeviceId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDeviceId()");
+	        } else {
+	            output = super.getDeviceId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDeviceId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDeviceId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getDeviceIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDeviceId()");
+				return output;
+			}
+			else{
+				output = settings.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDeviceId()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getDeviceSvn() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getSubscriberId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSubscriberId()");
+	        } else {
+	            output = super.getSubscriberId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSubscriberId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSubscriberId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getSubscriberIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSubscriberId()");
+				return output;
+			}
+			else{
+				output = settings.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSubscriberId()");
+				return output;
+			}
+		}
+		
+	}
+	
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getIccSerialNumber() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getEsn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMeid() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMsisdn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getImei() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo(){
+		PhoneSubInfo output = new PhoneSubInfo(this);
+		return output;
+	}
+	
+	@Override
+	public ServiceState getServiceState(){
+		ServiceState output;
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				//output.setRadioTechnology(-1);
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getServiceState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+		}
+	}
+	
+	
+}
diff --git a/src/java/android/privacy/surrogate/PrivacySipPhone.java b/src/java/android/privacy/surrogate/PrivacySipPhone.java
new file mode 100644
index 0000000..dbace04
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacySipPhone.java
@@ -0,0 +1,313 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.net.sip.SipProfile;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.sip.SipPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacySipPhone extends SipPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacySipPhone(Context context, PhoneNotifier pN, SipProfile sP) {
+		super(context, pN, sP); //I've changed the constructor to public!
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 1892427..dd569f6 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -16,6 +16,19 @@
 
 package com.android.internal.telephony;
 
+//BEGIN PRIVACY ADDED
+//--------------------------------------------------------
+//import com.android.internal.telephony.cdma.CDMAPhone;
+//import com.android.internal.telephony.cdma.CDMALTEPhone;
+//import com.android.internal.telephony.gsm.GSMPhone;
+import android.privacy.surrogate.PrivacyCDMAPhone;
+import android.privacy.surrogate.PrivacyCDMALTEPhone;
+import android.privacy.surrogate.PrivacyGSMPhone;
+import android.privacy.surrogate.PrivacySipPhone;
+import android.privacy.surrogate.PrivacyPhoneProxy;
+//--------------------------------------------------------
+//END PRIVACY ADDED
+
 import android.content.Context;
 import android.net.LocalServerSocket;
 import android.os.Looper;
@@ -24,10 +37,7 @@ import android.telephony.TelephonyManager;
 import android.util.Log;
 import android.os.SystemProperties;
 
-import com.android.internal.telephony.cdma.CDMAPhone;
-import com.android.internal.telephony.cdma.CDMALTEPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
-import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.sip.SipPhone;
 import com.android.internal.telephony.sip.SipPhoneFactory;
 import com.android.internal.telephony.uicc.UiccController;
@@ -145,20 +155,32 @@ public class PhoneFactory {
                 int phoneType = TelephonyManager.getPhoneType(networkMode);
                 if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                     Log.i(LOG_TAG, "Creating GSMPhone");
-                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
-                            sCommandsInterface, sPhoneNotifier));
+                    //BEGIN PRIVACY ADDED
+                    //sProxyPhone = new PhoneProxy(new GSMPhone(context,
+                    //        sCommandsInterface, sPhoneNotifier));
+                    sProxyPhone = new PrivacyPhoneProxy(new PrivacyGSMPhone(context,
+                            sCommandsInterface, sPhoneNotifier),context);
+                    //END PRIVACY ADDED
                 } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                     switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                         case PhoneConstants.LTE_ON_CDMA_TRUE:
                             Log.i(LOG_TAG, "Creating CDMALTEPhone");
-                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
-                                sCommandsInterface, sPhoneNotifier));
+                            //BEGIN PRIVACY ADDED
+                            //sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
+                            //    sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMALTEPhone(context,
+                                sCommandsInterface, sPhoneNotifier),context);
+                            //END PRIVACY ADDED
                             break;
                         case PhoneConstants.LTE_ON_CDMA_FALSE:
                         default:
                             Log.i(LOG_TAG, "Creating CDMAPhone");
-                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
-                                    sCommandsInterface, sPhoneNotifier));
+                            //BEGIN PRIVACY ADDED
+                            //sProxyPhone = new PhoneProxy(new CDMAPhone(context,
+                            //        sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMAPhone(context,
+                                    sCommandsInterface, sPhoneNotifier),context);
+                            //END PRIVACY ADDED
                             break;
                     }
                 }
@@ -185,13 +207,19 @@ public class PhoneFactory {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
             switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                 case PhoneConstants.LTE_ON_CDMA_TRUE: {
-                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
                 case PhoneConstants.LTE_ON_CDMA_FALSE:
                 case PhoneConstants.LTE_ON_CDMA_UNKNOWN:
                 default: {
-                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
             }
@@ -201,7 +229,7 @@ public class PhoneFactory {
 
     public static Phone getGsmPhone() {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
-            Phone phone = new GSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            Phone phone = new PrivacyGSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
             return phone;
         }
     }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index 6740372..fa7684e 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -74,6 +74,13 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.HashMap;
 import java.util.Random;
 
+// BEGIN PRIVACY ADDED
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END PRIVACY ADDED
+
 import static android.telephony.SmsManager.RESULT_ERROR_FDN_CHECK_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_LIMIT_EXCEEDED;
@@ -196,6 +203,123 @@ public abstract class SMSDispatcher extends Handler {
         sConcatenatedRef += 1;
         return sConcatenatedRef;
     }
+    
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSDispatcher";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    	        default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
 
     /**
      * Create a new SMS dispatcher.
@@ -218,7 +342,13 @@ public abstract class SMSDispatcher extends Handler {
                 Settings.Global.SMS_SHORT_CODE_RULE), false, mSettingsObserver);
 
         createWakelock();
-
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
+        if(pSetMan == null) new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         mSmsCapable = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_sms_capable);
         mSmsReceiveDisabled = !SystemProperties.getBoolean(
@@ -950,7 +1080,17 @@ public abstract class SMSDispatcher extends Handler {
             }
             return;
         }
-
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(), ACCESS_TYPE_SMS_MMS)){
+        	if (sentIntent != null) {
+                try {
+                    sentIntent.send(RESULT_ERROR_GENERIC_FAILURE);
+                    Log.i(TAG,"fake also delivery state to radio off!");
+                } catch (CanceledException e) {}
+            }
+        	return;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         HashMap<String, Object> map = new HashMap<String, Object>();
         map.put("smsc", smsc);
         map.put("pdu", pdu);
diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index c43888b..06de679 100755
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -822,7 +822,7 @@ public class CDMAPhone extends PhoneBase {
          super.notifyServiceStateChangedP(ss);
      }
 
-     void notifyLocationChanged() {
+     public void notifyLocationChanged() {
          mNotifier.notifyCellLocation(this);
      }
 
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 2554691..82880d6 100755
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -68,6 +68,15 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+/////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+/////////////////////////////////////////////////////////
+
+
 /**
  * {@hide}
  */
@@ -121,6 +130,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     String mSavedTimeZone;
     long mSavedTime;
     long mSavedAtTime;
+    
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
 
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
@@ -203,6 +217,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             Settings.System.getUriFor(Settings.System.AUTO_TIME_ZONE), true,
             mAutoTimeZoneObserver);
         setSignalStrengthDefaultValues();
+
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
     }
 
     @Override
@@ -371,10 +390,21 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                         loge("error parsing cell location data: " + ex);
                     }
                 }
-
-                cellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                	//we will update with invalid cell location values
+                	cellLoc.setStateInvalid();
+                }
+                else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                	Random values = new Random();
+                	cellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+                }
+                else{
+                	cellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+                }
                 phone.notifyLocationChanged();
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             // Release any temporary cell lock, which could have been
@@ -569,6 +599,7 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     protected void handlePollStateResultMessage(int what, AsyncResult ar){
         int ints[];
         String states[];
+  	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
         switch (what) {
         case EVENT_POLL_STATE_REGISTRATION_CDMA: // Handle RIL_REQUEST_REGISTRATION_STATE.
             states = (String[])ar.result;
@@ -658,8 +689,19 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
 
 
             // Values are -1 if not available.
-            newCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                    baseStationLongitude, systemId, networkId);
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
+            if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+            	//we will update with invalid cell location and station values
+            	newCellLoc.setStateInvalid();
+            }
+            else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+            	Random values = new Random();
+            	newCellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+            }
+            else{
+            	newCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+            }
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
 
             if (reasonForDenial == 0) {
                 mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
@@ -690,14 +732,25 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                                 "'= " + opNames[2]);
                     }
                 }
-
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
                 if (!isSubscriptionFromRuim) {
                     // In CDMA in case on NV, the ss.mOperatorAlphaLong is set later with the
                     // ERI text, so here it is ignored what is coming from the modem.
-                    newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName(null, "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	}
                 } else {
-                    newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName("", "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	}
                 }
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
             } else {
                 if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
             }
@@ -998,15 +1051,30 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             if ((cm.getRadioState().isOn()) && (!isSubscriptionFromRuim)) {
                 String eriText;
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
-                if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
-                    eriText = phone.getCdmaEriText();
-                } else {
-                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
-                    // mRegistrationState 0,2,3 and 4
-                    eriText = phone.getContext().getText(
-                            com.android.internal.R.string.roamingTextSearching).toString();
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = "";
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
+                } else{
+                	//original code
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = phone.getCdmaEriText();
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
                 }
                 ss.setOperatorAlphaLong(eriText);
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             String operatorNumeric;
diff --git a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
index 9cd059d..291b450 100644
--- a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
@@ -22,18 +22,27 @@ import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
-
 import com.android.internal.telephony.IccConstants;
 import com.android.internal.telephony.IccSmsInterfaceManager;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.PhoneProxy;
 import com.android.internal.telephony.SMSDispatcher;
 import com.android.internal.telephony.SmsRawData;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+
+/////////////////////////////////////////////////////////////
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+/////////////////////////////////////////////////////////////
+
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -51,6 +60,122 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_LOAD_DONE = 1;
     private static final int EVENT_UPDATE_DONE = 2;
 
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+	//-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    			default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    		
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
     Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -114,6 +239,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ pdu + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Updating message on RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -150,6 +282,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         //NOTE smsc not used in RUIM
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +312,12 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
@@ -218,5 +363,6 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     protected void log(String msg) {
         Log.d(LOG_TAG, "[RuimSmsInterfaceManager] " + msg);
     }
+    
 }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 393d101..419b79d 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -353,7 +353,7 @@ public class GSMPhone extends PhoneBase {
     /**
      * Notify any interested party of a Phone state change {@link PhoneConstants.State}
      */
-    /*package*/ void notifyPhoneStateChanged() {
+    /*package*/ public void notifyPhoneStateChanged() {
         mNotifier.notifyPhoneState(this);
     }
 
@@ -391,7 +391,7 @@ public class GSMPhone extends PhoneBase {
     }
 
     /*package*/
-    void notifyLocationChanged() {
+    public void notifyLocationChanged() {
         mNotifier.notifyCellLocation(this);
     }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 6110bd1..8baf415 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -53,6 +53,7 @@ import android.os.Message;
 import android.os.PowerManager;
 import android.os.Registrant;
 import android.os.RegistrantList;
+
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
@@ -67,7 +68,6 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.TimeUtils;
-
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -78,6 +78,14 @@ import java.util.Date;
 import java.util.HashSet;
 import java.util.TimeZone;
 
+//////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+//////////////////////////////////////////////////////////
+
 /**
  * {@hide}
  */
@@ -89,7 +97,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     GsmCellLocation cellLoc;
     GsmCellLocation newCellLoc;
     int mPreferredNetworkType;
-
+    
+    //--------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //--------------------------------------------------------------------------
+    
     private int gprsState = ServiceState.STATE_OUT_OF_SERVICE;
     private int newGPRSState = ServiceState.STATE_OUT_OF_SERVICE;
     private int mMaxDataCalls = 1;
@@ -234,7 +247,13 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         phone.getContext().registerReceiver(mIntentReceiver, filter);
-
+        
+        //--------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //--------------------------------------------------------------------------
+        
+        
         // Gsm doesn't support OTASP so its not needed
         phone.notifyOtaspChanged(OTASP_NOT_NEEDED);
     }
@@ -342,8 +361,24 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             Log.w(LOG_TAG, "error parsing location: " + ex);
                         }
                     }
-                    cellLoc.setLacAndCid(lac, cid);
-                    phone.notifyLocationChanged();
+                    //---------------------------------------------------------------------------------------------------------------------
+                    PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	cellLoc.setStateInvalid();
+                    	phone.notifyLocationChanged();
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	cellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        phone.notifyLocationChanged();
+                    }
+                    else{
+                    	cellLoc.setLacAndCid(lac, cid);
+                        phone.notifyLocationChanged();
+                    }
+                    //---------------------------------------------------------------------------------------------------------------------
+                    
                 }
 
                 // Release any temporary cell lock, which could have been
@@ -604,6 +639,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                         ar.exception);
             }
         } else try {
+        	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
             switch (what) {
                 case EVENT_POLL_STATE_REGISTRATION:
                     states = (String[])ar.result;
@@ -643,8 +679,23 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     }
 
                     // LAC and CID are -1 if not avail
-                    newCellLoc.setLacAndCid(lac, cid);
-                    newCellLoc.setPsc(psc);
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	newCellLoc.setStateInvalid();
+                        newCellLoc.setPsc(psc);
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	newCellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        newCellLoc.setPsc(psc);
+                    }
+                    else{
+                    	newCellLoc.setLacAndCid(lac, cid);
+                        newCellLoc.setPsc(psc);
+                    }
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    
                 break;
 
                 case EVENT_POLL_STATE_GPRS:
@@ -682,7 +733,14 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     String opNames[] = (String[])ar.result;
 
                     if (opNames != null && opNames.length >= 3) {
-                         newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                    	//--------------------------------------------------------------------------------------------------------------------------------
+                        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                        	newSS.setOperatorName ("", "", "");
+                        }
+                        else{
+                        	newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                        }
+                        //--------------------------------------------------------------------------------------------------------------------------------
                     }
                 break;
 
@@ -1041,7 +1099,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
 
         if (hasLocationChanged) {
-            phone.notifyLocationChanged();
+            phone.notifyLocationChanged(); //we can notify, because all sensitive data has changed before @author CollegeDev
         }
 
         if (! isGprsConsistent(gprsState, ss.getState())) {
diff --git a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
index 92bf390..7baf1ea 100644
--- a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
@@ -38,6 +38,13 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+//////////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+/////////////////////////////////////////////////////////////
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -63,6 +70,122 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_SET_BROADCAST_CONFIG_DONE = 4;
     private static final int SMS_CB_CODE_SCHEME_MIN = 0;
     private static final int SMS_CB_CODE_SCHEME_MAX = 255;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    	        default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    		
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
 
     Handler mHandler = new Handler() {
         @Override
@@ -136,6 +259,11 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ Arrays.toString(pdu) + ")");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         enforceReceiveAndSend("Updating message on SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +301,13 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) +
                 "), smsm=(" + Arrays.toString(smsc) +")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -198,6 +333,12 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
diff --git a/src/java/com/android/internal/telephony/sip/SipPhone.java b/src/java/com/android/internal/telephony/sip/SipPhone.java
index 346b126..fe91894 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhone.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhone.java
@@ -61,7 +61,7 @@ public class SipPhone extends SipPhoneBase {
     private SipManager mSipManager;
     private SipProfile mProfile;
 
-    SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
+    public SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
         super(context, notifier);
 
         if (DEBUG) Log.d(LOG_TAG, "new SipPhone: " + profile.getUriString());
diff --git a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
index 611e3ea..d4ddc1d 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
@@ -21,6 +21,7 @@ import com.android.internal.telephony.PhoneNotifier;
 import android.content.Context;
 import android.net.sip.SipProfile;
 import android.util.Log;
+import android.privacy.surrogate.PrivacySipPhone;
 
 import java.text.ParseException;
 
@@ -40,7 +41,7 @@ public class SipPhoneFactory {
             PhoneNotifier phoneNotifier) {
         try {
             SipProfile profile = new SipProfile.Builder(sipUri).build();
-            return new SipPhone(context, phoneNotifier, profile);
+            return new PrivacySipPhone(context, phoneNotifier, profile);
         } catch (ParseException e) {
             Log.w("SipPhoneFactory", "makePhone", e);
             return null;
